//! Internal router HTTP API
//!
//! Accepts PUT requests to deliver notifications to a connected client or trigger
//! a client to check storage.
//!
//! Valid URL's:
//!     PUT /push/UAID      - Deliver notification to a client
//!     PUT /notify/UAID    - Tell a client to check storage

use std::{str, sync::Arc};

use actix_http::Payload;
use actix_web::web;
use actix_web::{HttpResponse, HttpRequest};
use actix_web::http::Uri;
use hyper::{self, service::Service, Body, Method, Request, StatusCode};
use uuid::Uuid;

use autopush_common::errors::{ApiErrorKind, ApiResult};
use autopush_common::notification::Notification;

use crate::server::ServerOptions;
use crate::server::registry::ClientRegistry;

pub struct Push(pub Arc<ClientRegistry>);

impl Push {
    /// Get the UAID from the URI
    pub fn get_uaid(req: &HttpRequest) -> ApiResult<String> {
        let candidate = req.match_info().get("uaid").unwrap_or_else(|| {
            return Err(ApiErrorKind::GeneralError("Missing UAID from path".to_string()).into())
        })?;
        Ok(Uuid::parse_str(candidate))

    }

    /// receive a push notification directly from an endpoint server.
    pub async fn push(req: &HttpRequest, payload: &mut Payload, state: web::Data<ServerOptions>) -> ApiResult<HttpResponse>{
        let mut response = req.response();
        let uaid = Self::get_uaid(&req)?;
        trace!("## PUT /push/ {}", uaid);

        // read in the body from the payload
        let mut body = web::BytesMut::new();
        while let Some(chunk) = payload.next().await {
            let chunk = chunk?;
            // TODO:? if (body.len() + chunk.len()) > MAX_SIZE {return Err(...)}
            body.extend_from_slice(&chunk);
        }
        // generated by `autoendpoint::extractors::notiification::Notification::serialize_for_delivery`
        let msg = serde_json::from_slice::<Notification>(&body)?;
        //TODO: Finish delivery of notification to the client

        Ok(response)
    }

    /// wake a connected UAID to read it's pending queue.
    /// /notif/ messages carry no body, since the notification is already saved. Their role is to
    /// wake the node's uaid to fetch the new, pending message.
    pub async fn notif(req: HttpRequest, state: web::Data<ServerOptions>) -> ApiResult<HttpResponse> {
        let mut response = req.response();
        let uaid = Self::get_uaid(&req);
        //TODO: get the local list of registered UAIDs and send a bump message to that
        // socket handler so that it updates.
        Ok(response)

    }
}

/*
impl Service<Request> for Push {
    type Response = Body;
    type Error = hyper::Error;
    type Future = Box<dyn Future<Item = hyper::Response<Body>, Error = hyper::Error> + Send>;

    fn call(&mut self, req: hyper::Request<Body>) -> Self::Future {
        let mut response = hyper::Response::builder();
        let req_path = req.uri().path().to_string();
        let path_vec: Vec<&str> = req_path.split('/').collect();
        if path_vec.len() != 3 {
            response.status(StatusCode::NOT_FOUND);
            return Box::new(ok(response.body(Body::empty()).unwrap()));
        }
        let (method_name, uaid) = (path_vec[1], path_vec[2]);
        let uaid = match Uuid::parse_str(uaid) {
            Ok(id) => id,
            Err(_) => {
                debug!("uri not uuid: {}", req.uri().to_string());
                response.status(StatusCode::BAD_REQUEST);
                return Box::new(ok(response.body(Body::empty()).unwrap()));
            }
        };
        let clients = Arc::clone(&self.0);
        match (req.method(), method_name, uaid) {
            (&Method::PUT, "push", uaid) => {
                trace!("## PUT /push/ {}", uaid);
                // Due to consumption of body as a future we must return here
                let body = req.into_body().concat2();
                return Box::new(body.and_then(move |body| {
                    let s = String::from_utf8(body.to_vec()).unwrap();
                    if let Ok(msg) = serde_json::from_str(&s) {
                        Either::A(clients.notify(uaid, msg).then(move |result| {
                            let body = if result.is_ok() {
                                response.status(StatusCode::OK);
                                Body::empty()
                            } else {
                                response.status(StatusCode::NOT_FOUND);
                                Body::from("Client not available.")
                            };
                            Ok(response.body(body).unwrap())
                        }))
                    } else {
                        Either::B(ok(response
                            .status(hyper::StatusCode::BAD_REQUEST)
                            .body("Unable to decode body payload".into())
                            .unwrap()))
                    }
                }));
            }
            (&Method::PUT, "notif", uaid) => {
                trace!("## PUT /notif/ {}", uaid);
                return Box::new(clients.check_storage(uaid).then(move |result| {
                    let body = if result.is_ok() {
                        response.status(StatusCode::OK);
                        Body::empty()
                    } else {
                        response.status(StatusCode::NOT_FOUND);
                        Body::from("Client not available.")
                    };
                    Ok(response.body(body).unwrap())
                }));
            }
            (_, "push", _) | (_, "notif", _) => {
                response.status(StatusCode::METHOD_NOT_ALLOWED);
            }
            _ => {
                response.status(StatusCode::NOT_FOUND);
            }
        };
        Box::new(ok(response.body(Body::empty()).unwrap()))
    }
}
*/
